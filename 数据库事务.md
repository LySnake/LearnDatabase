### 13. 数据库事务

#### 13.1 数据库事务介绍

* 我们把完成特定的业务的多个数据库DML操作步骤称之为一个事务
* 事务，就是完成同一个业务的多个DML操作

    ```sql
    -- 借书业务
    -- 操作1：在借书记录表中添加记录
    insert into records(snum, bid, borrow_num, is_return, borrow_date) values('1001', 1, 1, 0, now());
    
    -- 操作2：修改图书库存
    update books set book_stock=book_stock-1 where book_id = 1;
    
    -- 转账业务：A向B转1000元
    -- 操作1：A的帐号-1000元
    -- 操作2：B的帐号+1000元
    ```

#### 13.2 数据库事务特性

##### 13.2.1 ACID特性

**原子性(Atomicity)**:一个事务中的多个DML操作，要么同时执行成功，要么同时执行失败

**一致性(Consistency)**:事务执行之前和事务执行之后，数据库中的数据是一致的，完整性和一致性不能被破坏

**隔离性(Isolation)**:数据库允许多个事务同时执行(张三借Java书的同时，允许李四借Java书)，多个并行的事务之间不能相互影响

**持久性(Durability)**:事务完成之后，对数据的操作是永久的

#### 13.3 MySQL事务管理

##### 13.3.1 自动提交与手动提交

* **DML指令流程**:当一条DML指令执行成功后，数据暂存在**连接缓存**中，通过**自动提交**或**手动提交**后才写入数据表中去。
* 在MySQL中，默认DML指令的执行是**自动提交**的，当我们执行一个DML指令之后，自动同步到数据库中。
* **自动提交**:一条DML指令执行后，立马把对数据表的修改、添加、删除写入数据库文件中。
* **手动提交**:一条DML指令执行后，数据暂存在**连接缓存中(每个Client都有一个连接缓存)**，直到主动发起 `commit`操作后，才会写入到数据表中去。

##### 13.3.2 事务管理

> 开启事务，就是关闭自动提交

* 在开始事务第一个操作之前，执行 `start transaction`开启事务
* 依次执行事务中的每个DML操作
* 如果在执行的过程中的任何位置出现异常，则执行 `rollback`回滚事务
* 如果事务中所有的DML操作都执行成功，则在最后执行 `commit`提交事务

```sql
-- 借书业务

-- 开启事务:关闭自动提交，启动手动提交
start transaction;

-- 操作1:在借书记录表中添加记录
insert into records(snum, bid, borrow_num, is_return, borrow_date) values('1007', 4, 2, 0, now());

-- 执行异常
-- 事务回滚:清除连接缓存中的操作，撤销当前事务已经执行的操作
-- rollback;

-- 操作2：修改图书库存
update books set book_stock=book_stock-1 where book_id = 4;

-- 提交事务:将连接缓存中的操作写入数据文件
commit;
```

#### 13.4 事务隔离级别

> 数据库允许多个事务并行，多个事务之间是隔离的、相互独立的；如果事务之间不相互隔离并且操作同一数据时，可能会导致数据的一致性被破坏。

MySQL数据库事务隔离级别:

**读未提交(read uncommitted)**:事务2可以读取事务1执行但未提交的数据；可能会导致出现脏读

> 脏读：一个事务读取了另一个事务中未提交的数据(最终因异常rollback后，并未提交)

**读已提交(read committed)**：事务2只能读取事务1已经提交的数据；可能会导致**不可重复读(虚读)**

> 不可重复读(虚读)：在同一个事务中，两次查询操作读取到的数据不一致
>
> 例如:事务2进行第一次查询之后，在第二次查询之前，事务1修改并提交了数据，事务2进行第二次查询时读取到的数据和第一次查询读取到的数据不一致。

**可重复读(repeatable read)**:事务2执行第一次查询后，在事务结束之前其它事务不能修改对应的数据；避免了不可重复读(虚读)，但可能会导致**幻读**

> 幻读：事务2对数据表中的数据进行修改然后查询，在查询之前事务1向数据表中新增了一条数据，就导致了事务2以为修改了所有数据，但却查询出了与修改不一致的数据(事务1新增的数据)

**串行化(serializable)**:同时只允许一个事务对数据表进行操作；避免了脏读、虚读、幻读的问题

|     隔离级别     | 脏读 | 不可重复读(虚读) | 幻读 |
| :--------------: | :--: | :--------------: | :--: |
| read uncommitted |  是  |        是        |  是  |
|  read committed  |  否  |        是        |  是  |
| repeatable read |  否  |        否        |  是  |
|   serializable   |  否  |        否        |  否  |

##### 13.4.5 设置数据库事务隔离级别

> 我们可以通过设置数据库默认的事务隔离级别来控制事务之间的隔离性；
>
> 也可以通过客户端与数据库连接来设置事务间的隔离性；MySQL数据库默认的隔离级别是 `可重复读`

* 查看MySQL数据库的默认的隔离级别

  ```sql
  -- 在MySQL 8.0.3 之前
  select @@tx_isolation;
  
  --在MySQL 8.0.3之后
  select @@transaction_isolation;
  ```
* 设置MySQL默认隔离级别

  ```sql
  set session transaction isolation level <read committed>;
  ```
